{"version":3,"file":"compress.min.js","sources":["../node_modules/exif-js/exif.js","../src/compress.js"],"sourcesContent":["(function() {\n\n    var debug = false;\n\n    var root = this;\n\n    var EXIF = function(obj) {\n        if (obj instanceof EXIF) return obj;\n        if (!(this instanceof EXIF)) return new EXIF(obj);\n        this.EXIFwrapped = obj;\n    };\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = EXIF;\n        }\n        exports.EXIF = EXIF;\n    } else {\n        root.EXIF = EXIF;\n    }\n\n    var ExifTags = EXIF.Tags = {\n\n        // version tags\n        0x9000 : \"ExifVersion\",             // EXIF version\n        0xA000 : \"FlashpixVersion\",         // Flashpix format version\n\n        // colorspace tags\n        0xA001 : \"ColorSpace\",              // Color space information tag\n\n        // image configuration\n        0xA002 : \"PixelXDimension\",         // Valid width of meaningful image\n        0xA003 : \"PixelYDimension\",         // Valid height of meaningful image\n        0x9101 : \"ComponentsConfiguration\", // Information about channels\n        0x9102 : \"CompressedBitsPerPixel\",  // Compressed bits per pixel\n\n        // user information\n        0x927C : \"MakerNote\",               // Any desired information written by the manufacturer\n        0x9286 : \"UserComment\",             // Comments by user\n\n        // related file\n        0xA004 : \"RelatedSoundFile\",        // Name of related sound file\n\n        // date and time\n        0x9003 : \"DateTimeOriginal\",        // Date and time when the original image was generated\n        0x9004 : \"DateTimeDigitized\",       // Date and time when the image was stored digitally\n        0x9290 : \"SubsecTime\",              // Fractions of seconds for DateTime\n        0x9291 : \"SubsecTimeOriginal\",      // Fractions of seconds for DateTimeOriginal\n        0x9292 : \"SubsecTimeDigitized\",     // Fractions of seconds for DateTimeDigitized\n\n        // picture-taking conditions\n        0x829A : \"ExposureTime\",            // Exposure time (in seconds)\n        0x829D : \"FNumber\",                 // F number\n        0x8822 : \"ExposureProgram\",         // Exposure program\n        0x8824 : \"SpectralSensitivity\",     // Spectral sensitivity\n        0x8827 : \"ISOSpeedRatings\",         // ISO speed rating\n        0x8828 : \"OECF\",                    // Optoelectric conversion factor\n        0x9201 : \"ShutterSpeedValue\",       // Shutter speed\n        0x9202 : \"ApertureValue\",           // Lens aperture\n        0x9203 : \"BrightnessValue\",         // Value of brightness\n        0x9204 : \"ExposureBias\",            // Exposure bias\n        0x9205 : \"MaxApertureValue\",        // Smallest F number of lens\n        0x9206 : \"SubjectDistance\",         // Distance to subject in meters\n        0x9207 : \"MeteringMode\",            // Metering mode\n        0x9208 : \"LightSource\",             // Kind of light source\n        0x9209 : \"Flash\",                   // Flash status\n        0x9214 : \"SubjectArea\",             // Location and area of main subject\n        0x920A : \"FocalLength\",             // Focal length of the lens in mm\n        0xA20B : \"FlashEnergy\",             // Strobe energy in BCPS\n        0xA20C : \"SpatialFrequencyResponse\",    //\n        0xA20E : \"FocalPlaneXResolution\",   // Number of pixels in width direction per FocalPlaneResolutionUnit\n        0xA20F : \"FocalPlaneYResolution\",   // Number of pixels in height direction per FocalPlaneResolutionUnit\n        0xA210 : \"FocalPlaneResolutionUnit\",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n        0xA214 : \"SubjectLocation\",         // Location of subject in image\n        0xA215 : \"ExposureIndex\",           // Exposure index selected on camera\n        0xA217 : \"SensingMethod\",           // Image sensor type\n        0xA300 : \"FileSource\",              // Image source (3 == DSC)\n        0xA301 : \"SceneType\",               // Scene type (1 == directly photographed)\n        0xA302 : \"CFAPattern\",              // Color filter array geometric pattern\n        0xA401 : \"CustomRendered\",          // Special processing\n        0xA402 : \"ExposureMode\",            // Exposure mode\n        0xA403 : \"WhiteBalance\",            // 1 = auto white balance, 2 = manual\n        0xA404 : \"DigitalZoomRation\",       // Digital zoom ratio\n        0xA405 : \"FocalLengthIn35mmFilm\",   // Equivalent foacl length assuming 35mm film camera (in mm)\n        0xA406 : \"SceneCaptureType\",        // Type of scene\n        0xA407 : \"GainControl\",             // Degree of overall image gain adjustment\n        0xA408 : \"Contrast\",                // Direction of contrast processing applied by camera\n        0xA409 : \"Saturation\",              // Direction of saturation processing applied by camera\n        0xA40A : \"Sharpness\",               // Direction of sharpness processing applied by camera\n        0xA40B : \"DeviceSettingDescription\",    //\n        0xA40C : \"SubjectDistanceRange\",    // Distance to subject\n\n        // other tags\n        0xA005 : \"InteroperabilityIFDPointer\",\n        0xA420 : \"ImageUniqueID\"            // Identifier assigned uniquely to each image\n    };\n\n    var TiffTags = EXIF.TiffTags = {\n        0x0100 : \"ImageWidth\",\n        0x0101 : \"ImageHeight\",\n        0x8769 : \"ExifIFDPointer\",\n        0x8825 : \"GPSInfoIFDPointer\",\n        0xA005 : \"InteroperabilityIFDPointer\",\n        0x0102 : \"BitsPerSample\",\n        0x0103 : \"Compression\",\n        0x0106 : \"PhotometricInterpretation\",\n        0x0112 : \"Orientation\",\n        0x0115 : \"SamplesPerPixel\",\n        0x011C : \"PlanarConfiguration\",\n        0x0212 : \"YCbCrSubSampling\",\n        0x0213 : \"YCbCrPositioning\",\n        0x011A : \"XResolution\",\n        0x011B : \"YResolution\",\n        0x0128 : \"ResolutionUnit\",\n        0x0111 : \"StripOffsets\",\n        0x0116 : \"RowsPerStrip\",\n        0x0117 : \"StripByteCounts\",\n        0x0201 : \"JPEGInterchangeFormat\",\n        0x0202 : \"JPEGInterchangeFormatLength\",\n        0x012D : \"TransferFunction\",\n        0x013E : \"WhitePoint\",\n        0x013F : \"PrimaryChromaticities\",\n        0x0211 : \"YCbCrCoefficients\",\n        0x0214 : \"ReferenceBlackWhite\",\n        0x0132 : \"DateTime\",\n        0x010E : \"ImageDescription\",\n        0x010F : \"Make\",\n        0x0110 : \"Model\",\n        0x0131 : \"Software\",\n        0x013B : \"Artist\",\n        0x8298 : \"Copyright\"\n    };\n\n    var GPSTags = EXIF.GPSTags = {\n        0x0000 : \"GPSVersionID\",\n        0x0001 : \"GPSLatitudeRef\",\n        0x0002 : \"GPSLatitude\",\n        0x0003 : \"GPSLongitudeRef\",\n        0x0004 : \"GPSLongitude\",\n        0x0005 : \"GPSAltitudeRef\",\n        0x0006 : \"GPSAltitude\",\n        0x0007 : \"GPSTimeStamp\",\n        0x0008 : \"GPSSatellites\",\n        0x0009 : \"GPSStatus\",\n        0x000A : \"GPSMeasureMode\",\n        0x000B : \"GPSDOP\",\n        0x000C : \"GPSSpeedRef\",\n        0x000D : \"GPSSpeed\",\n        0x000E : \"GPSTrackRef\",\n        0x000F : \"GPSTrack\",\n        0x0010 : \"GPSImgDirectionRef\",\n        0x0011 : \"GPSImgDirection\",\n        0x0012 : \"GPSMapDatum\",\n        0x0013 : \"GPSDestLatitudeRef\",\n        0x0014 : \"GPSDestLatitude\",\n        0x0015 : \"GPSDestLongitudeRef\",\n        0x0016 : \"GPSDestLongitude\",\n        0x0017 : \"GPSDestBearingRef\",\n        0x0018 : \"GPSDestBearing\",\n        0x0019 : \"GPSDestDistanceRef\",\n        0x001A : \"GPSDestDistance\",\n        0x001B : \"GPSProcessingMethod\",\n        0x001C : \"GPSAreaInformation\",\n        0x001D : \"GPSDateStamp\",\n        0x001E : \"GPSDifferential\"\n    };\n\n     // EXIF 2.3 Spec\n    var IFD1Tags = EXIF.IFD1Tags = {\n        0x0100: \"ImageWidth\",\n        0x0101: \"ImageHeight\",\n        0x0102: \"BitsPerSample\",\n        0x0103: \"Compression\",\n        0x0106: \"PhotometricInterpretation\",\n        0x0111: \"StripOffsets\",\n        0x0112: \"Orientation\",\n        0x0115: \"SamplesPerPixel\",\n        0x0116: \"RowsPerStrip\",\n        0x0117: \"StripByteCounts\",\n        0x011A: \"XResolution\",\n        0x011B: \"YResolution\",\n        0x011C: \"PlanarConfiguration\",\n        0x0128: \"ResolutionUnit\",\n        0x0201: \"JpegIFOffset\",    // When image format is JPEG, this value show offset to JPEG data stored.(aka \"ThumbnailOffset\" or \"JPEGInterchangeFormat\")\n        0x0202: \"JpegIFByteCount\", // When image format is JPEG, this value shows data size of JPEG image (aka \"ThumbnailLength\" or \"JPEGInterchangeFormatLength\")\n        0x0211: \"YCbCrCoefficients\",\n        0x0212: \"YCbCrSubSampling\",\n        0x0213: \"YCbCrPositioning\",\n        0x0214: \"ReferenceBlackWhite\"\n    };\n\n    var StringValues = EXIF.StringValues = {\n        ExposureProgram : {\n            0 : \"Not defined\",\n            1 : \"Manual\",\n            2 : \"Normal program\",\n            3 : \"Aperture priority\",\n            4 : \"Shutter priority\",\n            5 : \"Creative program\",\n            6 : \"Action program\",\n            7 : \"Portrait mode\",\n            8 : \"Landscape mode\"\n        },\n        MeteringMode : {\n            0 : \"Unknown\",\n            1 : \"Average\",\n            2 : \"CenterWeightedAverage\",\n            3 : \"Spot\",\n            4 : \"MultiSpot\",\n            5 : \"Pattern\",\n            6 : \"Partial\",\n            255 : \"Other\"\n        },\n        LightSource : {\n            0 : \"Unknown\",\n            1 : \"Daylight\",\n            2 : \"Fluorescent\",\n            3 : \"Tungsten (incandescent light)\",\n            4 : \"Flash\",\n            9 : \"Fine weather\",\n            10 : \"Cloudy weather\",\n            11 : \"Shade\",\n            12 : \"Daylight fluorescent (D 5700 - 7100K)\",\n            13 : \"Day white fluorescent (N 4600 - 5400K)\",\n            14 : \"Cool white fluorescent (W 3900 - 4500K)\",\n            15 : \"White fluorescent (WW 3200 - 3700K)\",\n            17 : \"Standard light A\",\n            18 : \"Standard light B\",\n            19 : \"Standard light C\",\n            20 : \"D55\",\n            21 : \"D65\",\n            22 : \"D75\",\n            23 : \"D50\",\n            24 : \"ISO studio tungsten\",\n            255 : \"Other\"\n        },\n        Flash : {\n            0x0000 : \"Flash did not fire\",\n            0x0001 : \"Flash fired\",\n            0x0005 : \"Strobe return light not detected\",\n            0x0007 : \"Strobe return light detected\",\n            0x0009 : \"Flash fired, compulsory flash mode\",\n            0x000D : \"Flash fired, compulsory flash mode, return light not detected\",\n            0x000F : \"Flash fired, compulsory flash mode, return light detected\",\n            0x0010 : \"Flash did not fire, compulsory flash mode\",\n            0x0018 : \"Flash did not fire, auto mode\",\n            0x0019 : \"Flash fired, auto mode\",\n            0x001D : \"Flash fired, auto mode, return light not detected\",\n            0x001F : \"Flash fired, auto mode, return light detected\",\n            0x0020 : \"No flash function\",\n            0x0041 : \"Flash fired, red-eye reduction mode\",\n            0x0045 : \"Flash fired, red-eye reduction mode, return light not detected\",\n            0x0047 : \"Flash fired, red-eye reduction mode, return light detected\",\n            0x0049 : \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n            0x004D : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n            0x004F : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n            0x0059 : \"Flash fired, auto mode, red-eye reduction mode\",\n            0x005D : \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n            0x005F : \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\n        },\n        SensingMethod : {\n            1 : \"Not defined\",\n            2 : \"One-chip color area sensor\",\n            3 : \"Two-chip color area sensor\",\n            4 : \"Three-chip color area sensor\",\n            5 : \"Color sequential area sensor\",\n            7 : \"Trilinear sensor\",\n            8 : \"Color sequential linear sensor\"\n        },\n        SceneCaptureType : {\n            0 : \"Standard\",\n            1 : \"Landscape\",\n            2 : \"Portrait\",\n            3 : \"Night scene\"\n        },\n        SceneType : {\n            1 : \"Directly photographed\"\n        },\n        CustomRendered : {\n            0 : \"Normal process\",\n            1 : \"Custom process\"\n        },\n        WhiteBalance : {\n            0 : \"Auto white balance\",\n            1 : \"Manual white balance\"\n        },\n        GainControl : {\n            0 : \"None\",\n            1 : \"Low gain up\",\n            2 : \"High gain up\",\n            3 : \"Low gain down\",\n            4 : \"High gain down\"\n        },\n        Contrast : {\n            0 : \"Normal\",\n            1 : \"Soft\",\n            2 : \"Hard\"\n        },\n        Saturation : {\n            0 : \"Normal\",\n            1 : \"Low saturation\",\n            2 : \"High saturation\"\n        },\n        Sharpness : {\n            0 : \"Normal\",\n            1 : \"Soft\",\n            2 : \"Hard\"\n        },\n        SubjectDistanceRange : {\n            0 : \"Unknown\",\n            1 : \"Macro\",\n            2 : \"Close view\",\n            3 : \"Distant view\"\n        },\n        FileSource : {\n            3 : \"DSC\"\n        },\n\n        Components : {\n            0 : \"\",\n            1 : \"Y\",\n            2 : \"Cb\",\n            3 : \"Cr\",\n            4 : \"R\",\n            5 : \"G\",\n            6 : \"B\"\n        }\n    };\n\n    function addEvent(element, event, handler) {\n        if (element.addEventListener) {\n            element.addEventListener(event, handler, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + event, handler);\n        }\n    }\n\n    function imageHasData(img) {\n        return !!(img.exifdata);\n    }\n\n\n    function base64ToArrayBuffer(base64, contentType) {\n        contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n        base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n        var binary = atob(base64);\n        var len = binary.length;\n        var buffer = new ArrayBuffer(len);\n        var view = new Uint8Array(buffer);\n        for (var i = 0; i < len; i++) {\n            view[i] = binary.charCodeAt(i);\n        }\n        return buffer;\n    }\n\n    function objectURLToBlob(url, callback) {\n        var http = new XMLHttpRequest();\n        http.open(\"GET\", url, true);\n        http.responseType = \"blob\";\n        http.onload = function(e) {\n            if (this.status == 200 || this.status === 0) {\n                callback(this.response);\n            }\n        };\n        http.send();\n    }\n\n    function getImageData(img, callback) {\n        function handleBinaryFile(binFile) {\n            var data = findEXIFinJPEG(binFile);\n            img.exifdata = data || {};\n            var iptcdata = findIPTCinJPEG(binFile);\n            img.iptcdata = iptcdata || {};\n            if (EXIF.isXmpEnabled) {\n               var xmpdata= findXMPinJPEG(binFile);\n               img.xmpdata = xmpdata || {};               \n            }\n            if (callback) {\n                callback.call(img);\n            }\n        }\n\n        if (img.src) {\n            if (/^data\\:/i.test(img.src)) { // Data URI\n                var arrayBuffer = base64ToArrayBuffer(img.src);\n                handleBinaryFile(arrayBuffer);\n\n            } else if (/^blob\\:/i.test(img.src)) { // Object URL\n                var fileReader = new FileReader();\n                fileReader.onload = function(e) {\n                    handleBinaryFile(e.target.result);\n                };\n                objectURLToBlob(img.src, function (blob) {\n                    fileReader.readAsArrayBuffer(blob);\n                });\n            } else {\n                var http = new XMLHttpRequest();\n                http.onload = function() {\n                    if (this.status == 200 || this.status === 0) {\n                        handleBinaryFile(http.response);\n                    } else {\n                        throw \"Could not load image\";\n                    }\n                    http = null;\n                };\n                http.open(\"GET\", img.src, true);\n                http.responseType = \"arraybuffer\";\n                http.send(null);\n            }\n        } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {\n            var fileReader = new FileReader();\n            fileReader.onload = function(e) {\n                if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\n                handleBinaryFile(e.target.result);\n            };\n\n            fileReader.readAsArrayBuffer(img);\n        }\n    }\n\n    function findEXIFinJPEG(file) {\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n            if (debug) console.log(\"Not a valid JPEG\");\n            return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength,\n            marker;\n\n        while (offset < length) {\n            if (dataView.getUint8(offset) != 0xFF) {\n                if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\n                return false; // not a valid marker, something is wrong\n            }\n\n            marker = dataView.getUint8(offset + 1);\n            if (debug) console.log(marker);\n\n            // we could implement handling for other markers here,\n            // but we're only looking for 0xFFE1 for EXIF data\n\n            if (marker == 225) {\n                if (debug) console.log(\"Found 0xFFE1 marker\");\n\n                return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\n\n                // offset += 2 + file.getShortAt(offset+2, true);\n\n            } else {\n                offset += 2 + dataView.getUint16(offset+2);\n            }\n\n        }\n\n    }\n\n    function findIPTCinJPEG(file) {\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n            if (debug) console.log(\"Not a valid JPEG\");\n            return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength;\n\n\n        var isFieldSegmentStart = function(dataView, offset){\n            return (\n                dataView.getUint8(offset) === 0x38 &&\n                dataView.getUint8(offset+1) === 0x42 &&\n                dataView.getUint8(offset+2) === 0x49 &&\n                dataView.getUint8(offset+3) === 0x4D &&\n                dataView.getUint8(offset+4) === 0x04 &&\n                dataView.getUint8(offset+5) === 0x04\n            );\n        };\n\n        while (offset < length) {\n\n            if ( isFieldSegmentStart(dataView, offset )){\n\n                // Get the length of the name header (which is padded to an even number of bytes)\n                var nameHeaderLength = dataView.getUint8(offset+7);\n                if(nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\n                // Check for pre photoshop 6 format\n                if(nameHeaderLength === 0) {\n                    // Always 4\n                    nameHeaderLength = 4;\n                }\n\n                var startOffset = offset + 8 + nameHeaderLength;\n                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n\n                return readIPTCData(file, startOffset, sectionLength);\n\n                break;\n\n            }\n\n\n            // Not the marker, continue searching\n            offset++;\n\n        }\n\n    }\n    var IptcFieldMap = {\n        0x78 : 'caption',\n        0x6E : 'credit',\n        0x19 : 'keywords',\n        0x37 : 'dateCreated',\n        0x50 : 'byline',\n        0x55 : 'bylineTitle',\n        0x7A : 'captionWriter',\n        0x69 : 'headline',\n        0x74 : 'copyright',\n        0x0F : 'category'\n    };\n    function readIPTCData(file, startOffset, sectionLength){\n        var dataView = new DataView(file);\n        var data = {};\n        var fieldValue, fieldName, dataSize, segmentType, segmentSize;\n        var segmentStartPos = startOffset;\n        while(segmentStartPos < startOffset+sectionLength) {\n            if(dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos+1) === 0x02){\n                segmentType = dataView.getUint8(segmentStartPos+2);\n                if(segmentType in IptcFieldMap) {\n                    dataSize = dataView.getInt16(segmentStartPos+3);\n                    segmentSize = dataSize + 5;\n                    fieldName = IptcFieldMap[segmentType];\n                    fieldValue = getStringFromDB(dataView, segmentStartPos+5, dataSize);\n                    // Check if we already stored a value with this name\n                    if(data.hasOwnProperty(fieldName)) {\n                        // Value already stored with this name, create multivalue field\n                        if(data[fieldName] instanceof Array) {\n                            data[fieldName].push(fieldValue);\n                        }\n                        else {\n                            data[fieldName] = [data[fieldName], fieldValue];\n                        }\n                    }\n                    else {\n                        data[fieldName] = fieldValue;\n                    }\n                }\n\n            }\n            segmentStartPos++;\n        }\n        return data;\n    }\n\n\n\n    function readTags(file, tiffStart, dirStart, strings, bigEnd) {\n        var entries = file.getUint16(dirStart, !bigEnd),\n            tags = {},\n            entryOffset, tag,\n            i;\n\n        for (i=0;i<entries;i++) {\n            entryOffset = dirStart + i*12 + 2;\n            tag = strings[file.getUint16(entryOffset, !bigEnd)];\n            if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\n            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\n        }\n        return tags;\n    }\n\n\n    function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n        var type = file.getUint16(entryOffset+2, !bigEnd),\n            numValues = file.getUint32(entryOffset+4, !bigEnd),\n            valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,\n            offset,\n            vals, val, n,\n            numerator, denominator;\n\n        switch (type) {\n            case 1: // byte, 8-bit unsigned int\n            case 7: // undefined, 8-bit byte, value depending on field\n                if (numValues == 1) {\n                    return file.getUint8(entryOffset + 8, !bigEnd);\n                } else {\n                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint8(offset + n);\n                    }\n                    return vals;\n                }\n\n            case 2: // ascii, 8-bit byte\n                offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n                return getStringFromDB(file, offset, numValues-1);\n\n            case 3: // short, 16 bit int\n                if (numValues == 1) {\n                    return file.getUint16(entryOffset + 8, !bigEnd);\n                } else {\n                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint16(offset + 2*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 4: // long, 32 bit int\n                if (numValues == 1) {\n                    return file.getUint32(entryOffset + 8, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 5:    // rational = two long values, first is numerator, second is denominator\n                if (numValues == 1) {\n                    numerator = file.getUint32(valueOffset, !bigEnd);\n                    denominator = file.getUint32(valueOffset+4, !bigEnd);\n                    val = new Number(numerator / denominator);\n                    val.numerator = numerator;\n                    val.denominator = denominator;\n                    return val;\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        numerator = file.getUint32(valueOffset + 8*n, !bigEnd);\n                        denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);\n                        vals[n] = new Number(numerator / denominator);\n                        vals[n].numerator = numerator;\n                        vals[n].denominator = denominator;\n                    }\n                    return vals;\n                }\n\n            case 9: // slong, 32 bit signed int\n                if (numValues == 1) {\n                    return file.getInt32(entryOffset + 8, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 10: // signed rational, two slongs, first is numerator, second is denominator\n                if (numValues == 1) {\n                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);\n                    }\n                    return vals;\n                }\n        }\n    }\n\n    /**\n    * Given an IFD (Image File Directory) start offset\n    * returns an offset to next IFD or 0 if it's the last IFD.\n    */\n    function getNextIFDOffset(dataView, dirStart, bigEnd){\n        //the first 2bytes means the number of directory entries contains in this IFD\n        var entries = dataView.getUint16(dirStart, !bigEnd);\n\n        // After last directory entry, there is a 4bytes of data,\n        // it means an offset to next IFD.\n        // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\n\n        return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long\n    }\n\n    function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd){\n        // get the IFD1 offset\n        var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart+firstIFDOffset, bigEnd);\n\n        if (!IFD1OffsetPointer) {\n            // console.log('******** IFD1Offset is empty, image thumb not found ********');\n            return {};\n        }\n        else if (IFD1OffsetPointer > dataView.byteLength) { // this should not happen\n            // console.log('******** IFD1Offset is outside the bounds of the DataView ********');\n            return {};\n        }\n        // console.log('*******  thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);\n\n        var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd)\n\n        // EXIF 2.3 specification for JPEG format thumbnail\n\n        // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\n        // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\n        // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\n        // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\n        // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\n\n        if (thumbTags['Compression']) {\n            // console.log('Thumbnail image found!');\n\n            switch (thumbTags['Compression']) {\n                case 6:\n                    // console.log('Thumbnail image format is JPEG');\n                    if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {\n                    // extract the thumbnail\n                        var tOffset = tiffStart + thumbTags.JpegIFOffset;\n                        var tLength = thumbTags.JpegIFByteCount;\n                        thumbTags['blob'] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {\n                            type: 'image/jpeg'\n                        });\n                    }\n                break;\n\n            case 1:\n                console.log(\"Thumbnail image format is TIFF, which is not implemented.\");\n                break;\n            default:\n                console.log(\"Unknown thumbnail image format '%s'\", thumbTags['Compression']);\n            }\n        }\n        else if (thumbTags['PhotometricInterpretation'] == 2) {\n            console.log(\"Thumbnail image format is RGB, which is not implemented.\");\n        }\n        return thumbTags;\n    }\n\n    function getStringFromDB(buffer, start, length) {\n        var outstr = \"\";\n        for (n = start; n < start+length; n++) {\n            outstr += String.fromCharCode(buffer.getUint8(n));\n        }\n        return outstr;\n    }\n\n    function readEXIFData(file, start) {\n        if (getStringFromDB(file, start, 4) != \"Exif\") {\n            if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\n            return false;\n        }\n\n        var bigEnd,\n            tags, tag,\n            exifData, gpsData,\n            tiffOffset = start + 6;\n\n        // test for TIFF validity and endianness\n        if (file.getUint16(tiffOffset) == 0x4949) {\n            bigEnd = false;\n        } else if (file.getUint16(tiffOffset) == 0x4D4D) {\n            bigEnd = true;\n        } else {\n            if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\n            return false;\n        }\n\n        if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {\n            if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\n            return false;\n        }\n\n        var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);\n\n        if (firstIFDOffset < 0x00000008) {\n            if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset+4, !bigEnd));\n            return false;\n        }\n\n        tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\n\n        if (tags.ExifIFDPointer) {\n            exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\n            for (tag in exifData) {\n                switch (tag) {\n                    case \"LightSource\" :\n                    case \"Flash\" :\n                    case \"MeteringMode\" :\n                    case \"ExposureProgram\" :\n                    case \"SensingMethod\" :\n                    case \"SceneCaptureType\" :\n                    case \"SceneType\" :\n                    case \"CustomRendered\" :\n                    case \"WhiteBalance\" :\n                    case \"GainControl\" :\n                    case \"Contrast\" :\n                    case \"Saturation\" :\n                    case \"Sharpness\" :\n                    case \"SubjectDistanceRange\" :\n                    case \"FileSource\" :\n                        exifData[tag] = StringValues[tag][exifData[tag]];\n                        break;\n\n                    case \"ExifVersion\" :\n                    case \"FlashpixVersion\" :\n                        exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\n                        break;\n\n                    case \"ComponentsConfiguration\" :\n                        exifData[tag] =\n                            StringValues.Components[exifData[tag][0]] +\n                            StringValues.Components[exifData[tag][1]] +\n                            StringValues.Components[exifData[tag][2]] +\n                            StringValues.Components[exifData[tag][3]];\n                        break;\n                }\n                tags[tag] = exifData[tag];\n            }\n        }\n\n        if (tags.GPSInfoIFDPointer) {\n            gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\n            for (tag in gpsData) {\n                switch (tag) {\n                    case \"GPSVersionID\" :\n                        gpsData[tag] = gpsData[tag][0] +\n                            \".\" + gpsData[tag][1] +\n                            \".\" + gpsData[tag][2] +\n                            \".\" + gpsData[tag][3];\n                        break;\n                }\n                tags[tag] = gpsData[tag];\n            }\n        }\n\n        // extract thumbnail\n        tags['thumbnail'] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);\n\n        return tags;\n    }\n\n   function findXMPinJPEG(file) {\n\n        if (!('DOMParser' in self)) {\n            // console.warn('XML parsing not supported without DOMParser');\n            return;\n        }\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n           if (debug) console.log(\"Not a valid JPEG\");\n           return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength,\n            dom = new DOMParser();\n\n        while (offset < (length-4)) {\n            if (getStringFromDB(dataView, offset, 4) == \"http\") {\n                var startOffset = offset - 1;\n                var sectionLength = dataView.getUint16(offset - 2) - 1;\n                var xmpString = getStringFromDB(dataView, startOffset, sectionLength)\n                var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;\n                xmpString = xmpString.substring( xmpString.indexOf( '<x:xmpmeta' ), xmpEndIndex );\n\n                var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10\n                //Many custom written programs embed xmp/xml without any namespace. Following are some of them.\n                //Without these namespaces, XML is thought to be invalid by parsers\n                xmpString = xmpString.slice(0, indexOfXmp)\n                            + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" '\n                            + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" '\n                            + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" '\n                            + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" '\n                            + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" '\n                            + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" '\n                            + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" '\n                            + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" '\n                            + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" '\n                            + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" '\n                            + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" '\n                            + xmpString.slice(indexOfXmp)\n\n                var domDocument = dom.parseFromString( xmpString, 'text/xml' );\n                return xml2Object(domDocument);\n            } else{\n             offset++;\n            }\n        }\n    }\n\n    function xml2json(xml) {\n        var json = {};\n      \n        if (xml.nodeType == 1) { // element node\n          if (xml.attributes.length > 0) {\n            json['@attributes'] = {};\n            for (var j = 0; j < xml.attributes.length; j++) {\n              var attribute = xml.attributes.item(j);\n              json['@attributes'][attribute.nodeName] = attribute.nodeValue;\n            }\n          }\n        } else if (xml.nodeType == 3) { // text node\n          return xml.nodeValue;\n        }\n      \n        // deal with children\n        if (xml.hasChildNodes()) {\n          for(var i = 0; i < xml.childNodes.length; i++) {\n            var child = xml.childNodes.item(i);\n            var nodeName = child.nodeName;\n            if (json[nodeName] == null) {\n              json[nodeName] = xml2json(child);\n            } else {\n              if (json[nodeName].push == null) {\n                var old = json[nodeName];\n                json[nodeName] = [];\n                json[nodeName].push(old);\n              }\n              json[nodeName].push(xml2json(child));\n            }\n          }\n        }\n        \n        return json;\n    }\n\n    function xml2Object(xml) {\n        try {\n            var obj = {};\n            if (xml.children.length > 0) {\n              for (var i = 0; i < xml.children.length; i++) {\n                var item = xml.children.item(i);\n                var attributes = item.attributes;\n                for(var idx in attributes) {\n                    var itemAtt = attributes[idx];\n                    var dataKey = itemAtt.nodeName;\n                    var dataValue = itemAtt.nodeValue;\n\n                    if(dataKey !== undefined) {\n                        obj[dataKey] = dataValue;\n                    }\n                }\n                var nodeName = item.nodeName;\n\n                if (typeof (obj[nodeName]) == \"undefined\") {\n                  obj[nodeName] = xml2json(item);\n                } else {\n                  if (typeof (obj[nodeName].push) == \"undefined\") {\n                    var old = obj[nodeName];\n\n                    obj[nodeName] = [];\n                    obj[nodeName].push(old);\n                  }\n                  obj[nodeName].push(xml2json(item));\n                }\n              }\n            } else {\n              obj = xml.textContent;\n            }\n            return obj;\n          } catch (e) {\n              console.log(e.message);\n          }\n    }\n\n    EXIF.enableXmp = function() {\n        EXIF.isXmpEnabled = true;\n    }\n\n    EXIF.disableXmp = function() {\n        EXIF.isXmpEnabled = false;\n    }\n\n    EXIF.getData = function(img, callback) {\n        if (((self.Image && img instanceof self.Image)\n            || (self.HTMLImageElement && img instanceof self.HTMLImageElement))\n            && !img.complete)\n            return false;\n\n        if (!imageHasData(img)) {\n            getImageData(img, callback);\n        } else {\n            if (callback) {\n                callback.call(img);\n            }\n        }\n        return true;\n    }\n\n    EXIF.getTag = function(img, tag) {\n        if (!imageHasData(img)) return;\n        return img.exifdata[tag];\n    }\n    \n    EXIF.getIptcTag = function(img, tag) {\n        if (!imageHasData(img)) return;\n        return img.iptcdata[tag];\n    }\n\n    EXIF.getAllTags = function(img) {\n        if (!imageHasData(img)) return {};\n        var a,\n            data = img.exifdata,\n            tags = {};\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                tags[a] = data[a];\n            }\n        }\n        return tags;\n    }\n    \n    EXIF.getAllIptcTags = function(img) {\n        if (!imageHasData(img)) return {};\n        var a,\n            data = img.iptcdata,\n            tags = {};\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                tags[a] = data[a];\n            }\n        }\n        return tags;\n    }\n\n    EXIF.pretty = function(img) {\n        if (!imageHasData(img)) return \"\";\n        var a,\n            data = img.exifdata,\n            strPretty = \"\";\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                if (typeof data[a] == \"object\") {\n                    if (data[a] instanceof Number) {\n                        strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\n                    } else {\n                        strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\n                    }\n                } else {\n                    strPretty += a + \" : \" + data[a] + \"\\r\\n\";\n                }\n            }\n        }\n        return strPretty;\n    }\n\n    EXIF.readFromBinaryFile = function(file) {\n        return findEXIFinJPEG(file);\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        define('exif-js', [], function() {\n            return EXIF;\n        });\n    }\n}.call(this));\n\n","/**\r\n * 说明\r\n * 这是一个压缩图片的工具库\r\n * 使用场景: 在浏览器上传图片前对图片压缩处理\r\n * 解决了什么问题:\r\n * 1. 通过canvas压缩\r\n * 2. IOS13.4之前 h5手机拍照后的图片自动旋转，IOS13.4之后这个问题又被修复的兼容\r\n * 3. 压缩后图可能会比原图大的问题\r\n * 4. png图片转jpeg时，透明区域被填充成黑色 https://evestorm.github.io/posts/46911/\r\n */\r\n\r\nimport EXIF from 'exif-js'\r\n\r\nconst Compress = function (file, config) {\r\n  this.defaultConfig = {\r\n    quality: 0.8, // 图片质量 0 - 1\r\n    useOriginal: false, // 是否采用原图宽度高度压缩 默认false 暂不支持自定义\r\n    width: 800, // 压缩后图片最大宽度 不支持自定义\r\n    height: 1200, // 压缩后图片最大高度 不支持自定义\r\n    success: noop, // 成功回调\r\n    fail: noop // 失败回调\r\n  }\r\n  this.config = { ...this.defaultConfig, ...config }\r\n  this.file = file\r\n  this.ctx = null\r\n  this.resize = null\r\n  this.core(file)\r\n}\r\n\r\n/**\r\n * 校验图片\r\n * @param { File } file\r\n */\r\nCompress.prototype.validate = function (file) {\r\n  const imgReg = /image\\/jpeg|image\\/jpg|image\\/png/\r\n  if (!document.createElement('canvas').getContext) {\r\n    throw new Error('浏览器不支持canvas')\r\n  }\r\n  if (!file) {\r\n    throw new Error('请传入图片!')\r\n  }\r\n  if (!imgReg.test(file.type)) {\r\n    throw new Error('非图片类型!,支持 jpeg, jpg, png')\r\n  }\r\n}\r\n\r\n/**\r\n * 图片压缩\r\n * @param { File } file 图片文件\r\n */\r\nCompress.prototype.core = function (file) {\r\n  try {\r\n    this.validate(file)\r\n    let result = {} // 返回结果对象\r\n    result.originalSize = getfilesize(file.size) // 原图大小\r\n    let orientation = ''\r\n    EXIF.getData(file, function () {\r\n      EXIF.getAllTags(this)\r\n      orientation = EXIF.getTag(this, 'Orientation')\r\n    })\r\n    const _this = this\r\n    let fileReader = new FileReader()\r\n    fileReader.onload = function (e) {\r\n      let image = new Image()\r\n      image.src = e.target.result\r\n\r\n      image.onerror = function () {\r\n        _this.config.fail('加载图片文件失败')\r\n      }\r\n\r\n      image.onload = function () {\r\n        const originalWidth = this.naturalWidth\r\n        const originalHeight = this.naturalHeight\r\n        result.originalReSize = { width: originalWidth, height: originalHeight } // 原图几何大小\r\n        _this.getResize(originalWidth, originalHeight) // 获取压缩后的图片几何大小\r\n        let { compressedWidth, compressedHeight } = _this.resize\r\n        result.resize = { width: compressedWidth, height: compressedHeight } // 压缩图几何大小\r\n        let canvas = document.createElement('canvas')\r\n        let ctx = canvas.getContext('2d')\r\n        this.ctx = ctx\r\n        canvas.width = compressedWidth\r\n        canvas.height = compressedHeight\r\n\r\n        // 在canvas绘制前填充白色背景\r\n        ctx.fillStyle = '#fff'\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n\r\n        ctx.drawImage(this, 0, 0, compressedWidth, compressedHeight)\r\n        _this.getBase64(orientation, canvas).then(base64 => {\r\n          result.size = getfilesize(base64.length) // 压缩后大小\r\n          result.base64 = base64\r\n          result.file = base64ConverFile(base64, file.name)\r\n          result.originFile = file\r\n          result.blob = dataURLtoBlob(base64)\r\n          result.blobUrl = URL.createObjectURL(result.blob)\r\n          _this.config.success(result)\r\n        })\r\n      }\r\n    }\r\n    fileReader.readAsDataURL(file)\r\n  } catch (error) {\r\n    this.config.fail(error)\r\n  }\r\n}\r\n\r\n/**\r\n * 获取图片getBase64\r\n */\r\nCompress.prototype.getBase64 = function (orientation, canvas) {\r\n  let base64 = null\r\n  const _this = this\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      detectImageAutomaticRotation().then(res => {\r\n        const isAutomaticRotation = res\r\n        // 如果是浏览器不会自动回正图片方向的iphone 则旋转方向\r\n        if (navigator.userAgent.match(/iphone/i && !isAutomaticRotation)) {\r\n          this.rotate(this, orientation)\r\n          base64 = canvas.toDataURL('image/jpeg', _this.config.quality)\r\n        } else {\r\n          base64 = canvas.toDataURL('image/jpeg', _this.config.quality)\r\n        }\r\n        resolve(base64)\r\n      })\r\n    } catch (error) {\r\n      reject(error)\r\n    }\r\n  })\r\n}\r\n\r\nCompress.prototype.rotate = function (img, orientation) {\r\n  // 调整为正确方向\r\n  const ctx = this.ctx\r\n  const resize = this.resize\r\n  /* eslint-disable indent */\r\n  switch (orientation) {\r\n    case 3:\r\n      ctx.rotate((180 * Math.PI) / 180)\r\n      ctx.drawImage(img, -resize.width, -resize.height, resize.width, resize.height)\r\n      break\r\n    case 6:\r\n      ctx.rotate((90 * Math.PI) / 180)\r\n      ctx.drawImage(img, 0, -resize.width, resize.height, resize.width)\r\n      break\r\n    case 8:\r\n      ctx.rotate((270 * Math.PI) / 180)\r\n      ctx.drawImage(img, -resize.height, 0, resize.height, resize.width)\r\n      break\r\n\r\n    case 2:\r\n      ctx.translate(resize.width, 0)\r\n      ctx.scale(-1, 1)\r\n      ctx.drawImage(img, 0, 0, resize.width, resize.height)\r\n      break\r\n    case 4:\r\n      ctx.translate(resize.width, 0)\r\n      ctx.scale(-1, 1)\r\n      ctx.rotate((180 * Math.PI) / 180)\r\n      ctx.drawImage(img, -resize.width, -resize.height, resize.width, resize.height)\r\n      break\r\n    case 5:\r\n      ctx.translate(resize.width, 0)\r\n      ctx.scale(-1, 1)\r\n      ctx.rotate((90 * Math.PI) / 180)\r\n      ctx.drawImage(img, 0, -resize.width, resize.height, resize.width)\r\n      break\r\n    case 7:\r\n      ctx.translate(resize.width, 0)\r\n      ctx.scale(-1, 1)\r\n      ctx.rotate((270 * Math.PI) / 180)\r\n      ctx.drawImage(img, -resize.height, 0, resize.height, resize.width)\r\n      break\r\n    default:\r\n      ctx.drawImage(img, 0, 0, resize.width, resize.height)\r\n  }\r\n}\r\n\r\n/**\r\n * 获取压缩后图片宽高\r\n */\r\nCompress.prototype.getResize = function (originalWidth, originalHeight) {\r\n  const { width, height } = this.config\r\n  let compressedWidth = originalWidth,\r\n    compressedHeight = originalHeight\r\n  if (originalWidth >= originalHeight && this.originalWidth > width) {\r\n    compressedWidth = width\r\n    compressedHeight = (compressedWidth * originalHeight) / originalWidth\r\n  } else if (originalHeight >= originalWidth && originalHeight > height) {\r\n    compressedHeight = height\r\n    compressedWidth = (compressedHeight * originalWidth) / originalHeight\r\n  }\r\n  this.resize = { compressedWidth, compressedHeight }\r\n}\r\n\r\n/**\r\n * base64Url转file文件域\r\n * @param {String} base64Url 必须，图片base64字符串\r\n * @param {String} filename\r\n */\r\nfunction base64ConverFile(base64Url, filename) {\r\n  let arr = base64Url.split(','),\r\n    mime = arr[0].match(/:(.*?);/)[1],\r\n    bstr = atob(arr[1]),\r\n    n = bstr.length,\r\n    u8arr = new Uint8Array(n)\r\n  while (n--) {\r\n    u8arr[n] = bstr.charCodeAt(n)\r\n  }\r\n  return new File([u8arr], filename, { type: mime })\r\n}\r\n\r\n/**\r\n * base64 -> blob\r\n * @param {String} base64Url\r\n */\r\nfunction dataURLtoBlob(base64Url) {\r\n  let binary = atob(base64Url.split(',')[1])\r\n  let array = []\r\n  for (let i = 0; i < binary.length; i++) {\r\n    array.push(binary.charCodeAt(i))\r\n  }\r\n  return new Blob([new Uint8Array(array)], { type: 'image/jpeg' })\r\n}\r\n\r\n/**\r\n * 判断浏览器是否自动回正图片\r\n */\r\nfunction detectImageAutomaticRotation() {\r\n  const testAutoOrientationImageURL =\r\n    'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +\r\n    'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +\r\n    'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +\r\n    'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/x' +\r\n    'ABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAA' +\r\n    'AAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q=='\r\n  let isImageAutomaticRotation\r\n  return new Promise(resolve => {\r\n    if (isImageAutomaticRotation === undefined) {\r\n      const img = new Image()\r\n      img.onload = () => {\r\n        // 如果图片变成 1x2，说明浏览器对图片进行了回正\r\n        isImageAutomaticRotation = img.width === 1 && img.height === 2\r\n        resolve(isImageAutomaticRotation)\r\n      }\r\n      img.src = testAutoOrientationImageURL\r\n    } else {\r\n      resolve(isImageAutomaticRotation)\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * 文件大小格式化\r\n * @param { Number } size 文件字节数\r\n */\r\nfunction getfilesize(size) {\r\n  if (!size) return ''\r\n  const num = 1024.0 // byte\r\n  if (size < num) return size + 'B'\r\n  if (size < Math.pow(num, 2)) return (size / num).toFixed(2) + 'K' // kb\r\n  if (size < Math.pow(num, 3)) return (size / Math.pow(num, 2)).toFixed(2) + 'M' // M\r\n  if (size < Math.pow(num, 4)) return (size / Math.pow(num, 3)).toFixed(2) + 'G' // G\r\n  return (size / Math.pow(num, 4)).toFixed(2) + 'T' // T\r\n}\r\n\r\nfunction noop() {\r\n  return () => {}\r\n}\r\n\r\nexport default Compress\r\n"],"names":["EXIF","obj","this","EXIFwrapped","module","exports","ExifTags","Tags","TiffTags","GPSTags","IFD1Tags","StringValues","ExposureProgram","MeteringMode","LightSource","Flash","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","Components","imageHasData","img","exifdata","getImageData","callback","handleBinaryFile","binFile","data","findEXIFinJPEG","iptcdata","file","dataView","DataView","getUint8","offset","length","byteLength","isFieldSegmentStart","nameHeaderLength","readIPTCData","getUint16","findIPTCinJPEG","isXmpEnabled","xmpdata","self","dom","DOMParser","getStringFromDB","startOffset","sectionLength","xmpString","xmpEndIndex","indexOf","indexOfXmp","substring","slice","xml2Object","parseFromString","findXMPinJPEG","call","src","test","base64","contentType","match","replace","binary","atob","len","buffer","ArrayBuffer","view","Uint8Array","i","charCodeAt","base64ToArrayBuffer","fileReader","FileReader","onload","e","target","result","url","http","XMLHttpRequest","open","responseType","status","response","send","objectURLToBlob","blob","readAsArrayBuffer","Blob","File","readEXIFData","IptcFieldMap","fieldValue","fieldName","dataSize","segmentType","segmentStartPos","getInt16","hasOwnProperty","Array","push","readTags","tiffStart","dirStart","strings","bigEnd","entryOffset","entries","tags","readTagValue","vals","val","n","numerator","denominator","type","numValues","getUint32","valueOffset","Number","getInt32","start","outstr","String","fromCharCode","tag","exifData","gpsData","tiffOffset","firstIFDOffset","ExifIFDPointer","GPSInfoIFDPointer","IFD1OffsetPointer","getNextIFDOffset","thumbTags","JpegIFOffset","JpegIFByteCount","tOffset","tLength","console","log","readThumbnailImage","xml2json","xml","json","nodeType","attributes","j","attribute","item","nodeName","nodeValue","hasChildNodes","childNodes","child","old","children","idx","itemAtt","dataKey","dataValue","undefined","textContent","message","enableXmp","disableXmp","getData","Image","HTMLImageElement","complete","getTag","getIptcTag","getAllTags","a","getAllIptcTags","pretty","strPretty","readFromBinaryFile","Compress","config","defaultConfig","quality","useOriginal","width","height","success","noop","fail","ctx","resize","core","getfilesize","size","num","Math","pow","toFixed","prototype","validate","document","createElement","getContext","Error","originalSize","orientation","_this","image","onerror","originalWidth","naturalWidth","originalHeight","naturalHeight","originalReSize","getResize","compressedWidth","compressedHeight","canvas","fillStyle","fillRect","drawImage","getBase64","then","base64Url","filename","arr","split","mime","bstr","u8arr","base64ConverFile","name","originFile","array","dataURLtoBlob","blobUrl","URL","createObjectURL","readAsDataURL","error","Promise","resolve","reject","testAutoOrientationImageURL","isImageAutomaticRotation","res","isAutomaticRotation","navigator","userAgent","_this2","rotate","toDataURL","PI","translate","scale"],"mappings":"6lCAAC,eAMOA,EAAO,SAASC,UACZA,aAAeD,EAAaC,EAC1BC,gBAAgBF,YACjBG,YAAcF,GADiB,IAAID,EAAKC,IAKRG,EAAOC,UACxCA,EAAUD,UAAiBJ,GAE/BK,OAAeL,MAKfM,EAAWN,EAAKO,KAAO,OAGd,oBACA,wBAGA,mBAGA,wBACA,wBACA,gCACA,+BAGA,kBACA,oBAGA,yBAGA,yBACA,0BACA,mBACA,2BACA,4BAGA,qBACA,gBACA,wBACA,4BACA,wBACA,aACA,0BACA,sBACA,wBACA,qBACA,yBACA,wBACA,qBACA,oBACA,cACA,oBACA,oBACA,oBACA,iCACA,8BACA,8BACA,iCACA,wBACA,sBACA,sBACA,mBACA,kBACA,mBACA,uBACA,qBACA,qBACA,0BACA,8BACA,yBACA,oBACA,iBACA,mBACA,kBACA,iCACA,6BAGA,mCACA,iBAGTC,EAAWR,EAAKQ,SAAW,KAClB,iBACA,oBACA,uBACA,0BACA,iCACA,oBACA,kBACA,gCACA,kBACA,sBACA,0BACA,uBACA,uBACA,kBACA,kBACA,qBACA,mBACA,mBACA,sBACA,4BACA,kCACA,uBACA,iBACA,4BACA,wBACA,0BACA,eACA,uBACA,WACA,YACA,eACA,eACA,aAGTC,EAAUT,EAAKS,QAAU,GAChB,iBACA,mBACA,gBACA,oBACA,iBACA,mBACA,gBACA,iBACA,kBACA,eACA,oBACA,YACA,iBACA,cACA,iBACA,cACA,wBACA,qBACA,iBACA,wBACA,qBACA,yBACA,sBACA,uBACA,oBACA,wBACA,qBACA,yBACA,wBACA,kBACA,mBAITC,EAAWV,EAAKU,SAAW,KACnB,iBACA,kBACA,oBACA,kBACA,gCACA,mBACA,kBACA,sBACA,mBACA,sBACA,kBACA,kBACA,0BACA,qBACA,mBACA,sBACA,wBACA,uBACA,uBACA,uBAGRC,EAAeX,EAAKW,aAAe,CACnCC,gBAAkB,GACV,gBACA,WACA,mBACA,sBACA,qBACA,qBACA,mBACA,kBACA,kBAERC,aAAe,GACP,YACA,YACA,0BACA,SACA,cACA,YACA,cACE,SAEVC,YAAc,GACN,YACA,aACA,gBACA,kCACA,UACA,kBACC,oBACA,WACA,2CACA,4CACA,6CACA,yCACA,sBACA,sBACA,sBACA,SACA,SACA,SACA,SACA,0BACC,SAEVC,MAAQ,GACK,uBACA,gBACA,qCACA,iCACA,wCACA,mEACA,+DACA,+CACA,mCACA,4BACA,uDACA,mDACA,uBACA,yCACA,oEACA,gEACA,gEACA,2FACA,uFACA,oDACA,+EACA,yEAEbC,cAAgB,GACR,gBACA,+BACA,+BACA,iCACA,iCACA,qBACA,kCAERC,iBAAmB,GACX,aACA,cACA,aACA,eAERC,UAAY,GACJ,yBAERC,eAAiB,GACT,mBACA,kBAERC,aAAe,GACP,uBACA,wBAERC,YAAc,GACN,SACA,gBACA,iBACA,kBACA,kBAERC,SAAW,GACH,WACA,SACA,QAERC,WAAa,GACL,WACA,mBACA,mBAERC,UAAY,GACJ,WACA,SACA,QAERC,qBAAuB,GACf,YACA,UACA,eACA,gBAERC,WAAa,GACL,OAGRC,WAAa,GACL,KACA,MACA,OACA,OACA,MACA,MACA,eAYHC,EAAaC,WACRA,EAAIC,kBA6BTC,EAAaF,EAAKG,YACdC,EAAiBC,OAClBC,EAAOC,EAAeF,GAC1BL,EAAIC,SAAWK,GAAQ,OACnBE,WAyFYC,OAChBC,EAAW,IAAIC,SAASF,MAGC,KAAxBC,EAASE,SAAS,IAAwC,KAAxBF,EAASE,SAAS,UAE9C,MAGPC,EAAS,EACTC,EAASL,EAAKM,WAGdC,EAAsB,SAASN,EAAUG,UAEP,KAA9BH,EAASE,SAASC,IACc,KAAhCH,EAASE,SAASC,EAAO,IACO,KAAhCH,EAASE,SAASC,EAAO,IACO,KAAhCH,EAASE,SAASC,EAAO,IACO,IAAhCH,EAASE,SAASC,EAAO,IACO,IAAhCH,EAASE,SAASC,EAAO,SAI1BA,EAASC,GAAQ,IAEfE,EAAoBN,EAAUG,GAAS,KAGpCI,EAAmBP,EAASE,SAASC,EAAO,UAC7CI,EAAmB,GAAM,IAAGA,GAAoB,GAE3B,IAArBA,IAECA,EAAmB,GAMhBC,EAAaT,EAHF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"}